<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <!-- <meta name="description" content="Zine: Fast, Scalable and Flexible Static Site Generator"> -->
    <!-- <meta name="twitter:card" content="summary"> -->
    <!-- <meta name="twitter:site" content="@zml.ai"> -->
    <!-- <meta name="twitter:author" content="@zml.ai"> -->
    <!-- <meta name="twitter:description" content="Zine: Fast, Scalable and Flexible Static Site Generator"> -->
    <!-- <meta name="twitter:title" content="$page.title.suffix(' | ZML')"> -->
    <meta property="og:title" content="ZML Concepts">
    <meta property="og:type" content="website">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      ZML Concepts
      - ZML
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    <link rel="icon" href="/zml.no_light.svg">
    
  </head>
  <body>
    <a id="logo" href="/"></a>
    <nav id="menu">
      <a href="/">Home</a>
      •
      <a href="/tutorials/getting_started/">Quickstart</a>
      •
      <a href="/tutorials/write_first_model/">First Steps</a>
      <!-- • -->
      <!-- <a href="$site.page('concepts').link()">Concepts</a> -->
      <!-- • -->
      <!-- <a href="$site.page('using_zml_in_own_projects').link()">Using it in projects</a> -->
      •
      <a href="/misc/zml_api/">API Docs</a>
      •
      <a href="https://github.com/zml/zml" target="_blank">Code</a>
      •
      <a href="https://discord.gg/6y72SN2E7H" target="_blank">Discord</a>
    </nav>
    <!-- <hr style="width:min(600px, 100vw); border-color:#0798b3; color: white; border-top:1px;"> -->
    <aside id="sidebar" class="sidebar">
        <!-- <h3>Docs</h3> -->
        <a href="/tutorials/"><h5>Tutorials</h5></a>
        <div class="linkbox">
            <div><a href="/tutorials/getting_started/">Getting Started with ZML</a></div>
        
            <div><a href="/tutorials/write_first_model/">Writing your first model</a></div>
        
            <div><a href="/tutorials/working_with_tensors/">Simplifying Dimension Handling with Tagged Tensors</a></div>
        </div>
        <a href="/howtos/"><h5>How-Tos</h5></a>
        <div class="linkbox">
            <div><a href="/howtos/huggingface_access_token/">Huggingface Token Authentication</a></div>
        
            <div><a href="/howtos/dockerize_models/">Dockerize a Model</a></div>
        
            <div><a href="/howtos/deploy_on_server/">Deploying Models on a Server</a></div>
        
            <div><a href="/howtos/howto_torch2zml/">How to port Pytorch models to ZML ?</a></div>
        
            <div><a href="/howtos/add_weights/">Adding Weights Files</a></div>
        </div>
        <a href="/tutorials/"><h5>Learn more</h5></a>
        <div class="linkbox">
            <div><a href="/learn/concepts/">ZML Concepts</a></div>
        </div>
        <a href="/tutorials/"><h5>Misc</h5></a>
        <div class="linkbox">
            <div><a href="/misc/style_guide/">ZML Style Guide</a></div>
        
            <div><a href="/misc/zml_api/">API Docs</a></div>
        
            <div><a href="/misc/CHANGELOG/">ZML Changelog</a></div>
        </div>
    </aside>

    <main>
        <div id="content">
  <style>
    h1 {
       margin-top: 0;
     }

		#docs h2, #docs h3 {
			text-align: left;
		}

		#docs h3 {
			font-size: 1.2rem;
		}

		#docs h3::before {
      content: "##";
      font-size: 1rem;
      padding-right: 4px;
      margin-bottom: 0;
    }

    #docs h2 {
      font-size: 1.5rem;
      border-bottom: 1px dashed #aaa;
    }

    #docs h2::before {
      content: "#";
      font-size: 1rem;
      padding-right: 4px;
    }

    #docs h4 {
      font-size: 1rem;
    }

    table {
      font-size: 0.9em;
    }
    table th {
      font-size: 1em;
    }
    table td {
      white-space: nowrap;
    }
  </style>
  <h3 class="centered"></h3>
  <script>
    // Find all short <code> elements in the document, and replace them with links to our docs, or pytorch docs.
    document.addEventListener('DOMContentLoaded', function() {
      const codeElements = document.querySelectorAll('code');

      codeElements.forEach(function(codeElement) {
          const codeContent = codeElement.textContent;
          if (codeContent.includes(' ')) return;

          if (codeContent.startsWith('zml.')) {
            const linkElement = document.createElement('a');
            linkElement.href = "/misc/zml_api/#" + codeContent;
            linkElement.textContent = codeContent;
            codeElement.replaceWith(linkElement);
          } else if (codeContent.startsWith('torch.')) {
            const linkElement = document.createElement('a');
            linkElement.href = "https://pytorch.org/docs/stable/generated/" + codeContent;
            linkElement.textContent = codeContent;
            codeElement.replaceWith(linkElement);
          }
      });
  });
  </script>
  <!-- <h1 :text="$page.title"></h1> -->
  <div id="docs"><h1 id="zml-concepts">ZML Concepts</h1><h2 id="model-lifecycle">Model lifecycle</h2><p>ZML is a library that help running Machine Learning (ML) models, and particulary Neural Networks (NN).</p><p>The lifecycle of a model is the following:</p><ol><li><p>Open the model file and read the shapes of the weights, but leave the weights on the disk.</p></li><li><p>Using the metadata, instantiate a model struct with <code>Tensor</code>s representing the shape and layout of each layer of the NN.</p></li><li><p>Compile the model struct and it's <code>forward</code> method into an accelerator specific executable. The <code>forward</code> method describes the mathematical operations corresponding to the model inference.</p></li><li><p>Load the model weights from the disk, onto the accelerator memory.</p></li><li><p>Bind the model weights to the executable.</p></li><li><p>Load some user inputs, and copy them to the accelerator.</p></li><li><p>Call the executable on the user inputs.</p></li><li><p>Return the model output to the host, and finally to the user.</p></li><li><p>When all user inputs have been processed, free the executable resources and the associated weights.</p></li></ol><p><strong>Some details:</strong></p><p>Note that the compilation and weight loading steps are both bottlenecks to your model startup time, but they can be done in parallel. ZML provides asynchronous primitive to make that easy.</p><p>The compilation can be cached across runs, and if you're always using the same model architecture with the same shapes, it's possible to by-pass it entirely.</p><p>The accelerator is typically a GPU, but can be another chip, or even the CPU itself churning vector instructions.</p><h2 id="tensor-bros">Tensor Bros.</h2><p>In ZML we leverage Zig static type system to differentiate between a few concepts, hence we not only have <code>Tensor</code> like other ML framework, but also <code>Buffer</code>, <code>HostBuffer</code> and <code>Shape</code>. Let's explain all that.</p><ul><li><p><code>Shape</code>: <em>describes</em> a multi-dimension array.</p><ul><li><code>Shape.init(.{16}, .f32)</code> represents a vector of 16 floats with 32 bits precision.</li><li><code>Shape.init(.{512, 1024}, .f16)</code> represents a matrix of <code>512*1024</code> floats with 16 bits precision, ie a <code>[512][1024]f16</code> array.</li></ul><p>The <code>Shape</code> is only metadata, it doesn't point to or own any memory. The <code>Shape</code> struct can also represent regular number, aka scalar: <code>Shape.init(.{}, .i32)</code> represents a 32-bit signed integer.</p></li><li><p><code>HostBuffer</code>: <em>is</em> a multi-dimension array, whose memory is allocated on the CPU.</p><ul><li>points to the slice of memory containing the array</li><li>typically owns the underlying memory, but has a flag to remember when it doesn't.</li></ul></li><li><p><code>Buffer</code>: <em>is</em> a multi-dimension array, whose memory is allocated on an accelerator.</p><ul><li>contains a handle that the ZML runtime can use to convert into a physical address, but there is no guarantee this address is visible from the CPU.</li><li>can be created by loading weights from disk directly to the device <code>zml.aio.loadBuffers</code></li><li>can be created by calling <code>HostBuffer.toDevice(accelerator)</code>.</li></ul></li><li><p><code>Tensor</code>: is a mathematical object representing an intermediary result of a computation.</p><ul><li>is basically a <code>Shape</code> and an MLIR value representing the mathematical operation that produced this <code>Tensor</code>.</li></ul></li></ul><h2 id="the-model-struct">The model struct</h2><p>The model struct is the Zig code that describe your Neural Network (NN). Let's look a the following model architecture:</p><p><figure><img src="https://zml.ai/docs-assets/perceptron.png">
<figcaption>Multilayer perceptrons</figcaption></figure></p><p>This is how we can describe it in a Zig struct:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">Model</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">input_layer</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation delimiter">,</span>
    <span class="field">output_layer</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation delimiter">,</span>

    <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">forward</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Model</span><span class="punctuation delimiter">,</span> <span class="parameter">input</span><span class="punctuation delimiter">:</span> <span class="variable">Tensor</span><span class="punctuation bracket">)</span> <span class="variable">Tensor</span> <span class="punctuation bracket">{</span>
      <span class="type qualifier">const</span> <span class="variable">hidden</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">input_layer</span><span class="punctuation delimiter">.</span><span class="function">matmul</span><span class="punctuation bracket">(</span><span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="type qualifier">const</span> <span class="variable">output</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">output_layer</span><span class="punctuation delimiter">.</span><span class="function">matmul</span><span class="punctuation bracket">(</span><span class="variable">hidden</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="keyword return">return</span> <span class="variable">output</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter"></span>
</code></pre>
<p>NN are generally seen as a composition of smaller NN which split into layers. ZML make it easy to mirror this structure in your code.</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">Model</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">input_layer</span><span class="punctuation delimiter">:</span> <span class="variable">MyOtherLayer</span><span class="punctuation delimiter">,</span>
    <span class="field">output_layer</span><span class="punctuation delimiter">:</span> <span class="variable">MyLastLayer</span><span class="punctuation delimiter">,</span>

    <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">forward</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Model</span><span class="punctuation delimiter">,</span> <span class="parameter">input</span><span class="punctuation delimiter">:</span> <span class="variable">Tensor</span><span class="punctuation bracket">)</span> <span class="variable">Tensor</span> <span class="punctuation bracket">{</span>
      <span class="type qualifier">const</span> <span class="variable">hidden</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">input_layer</span><span class="punctuation delimiter">.</span><span class="function">forward</span><span class="punctuation bracket">(</span><span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="type qualifier">const</span> <span class="variable">output</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">output_layer</span><span class="punctuation delimiter">.</span><span class="function">forward</span><span class="punctuation bracket">(</span><span class="variable">hidden</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="keyword return">return</span> <span class="variable">output</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter"></span>
</code></pre>
<p><code>zml.nn</code> module provides a number of well known layers to more easily bootstrap models.</p><p>Since the <code>Model</code> struct contains <code>Tensor</code>, it's only ever useful during the compilation stage, but not during inference. If we want to represent the model with actual <code>Buffer</code>, we can use the <code>zml.Bufferize(Model)</code> which is a mirror struct from <code>Model</code> but with <code>Buffer</code> replacing every <code>Tensor</code>.</p><h2 id="strong-type-checking">Strong type checking</h2><p>Let's look a again a the model life cycle, but this time, annotated with the corresponding types.</p><ol><li><p>Open the model file and read the shapes of the weights -> <code>zml.HostBuffer</code> (using memory mapping no actual copy happen yet)</p></li><li><p>Instantiate a model struct -> <code>Model</code> struct (with <code>Tensor</code> inside)</p></li><li><p>Compile the model struct and it's <code>forward</code> into an executable. <code>foward</code> is a <code>Tensor -&gt; Tensor</code> function, executable is a <code>zml.Exe(Model.forward)</code></p></li><li><p>Load the model weights from the disk, onto the accelerator memory -> <code>zml.Bufferized(Model)</code> struct (with <code>Buffer</code> inside)</p></li><li><p>Bind the model weights to the executable <code>zml.ExeWithWeight(Model.forward)</code></p></li><li><p>Load some user inputs (custom struct), encode it to arrays of numbers (<code>zml.HostBuffer</code>) and copy them to the accelerator (zml.Buffer).</p></li><li><p>Call the executable on the user inputs. <code>module.call</code> accepts <code>Buffer</code> arguments and returns <code>Buffer</code></p></li><li><p>Return the model output (<code>zml.Buffer</code>) to the host (<code>zml.HostBuffer</code>), decode it (custom struct) and finally return to the user.</p></li></ol></div>
</div>
    </main>


    <footer>
        <!-- OPTION 1: with Zine -->
        <b>&copy; in 2024 by <a href="https://zml.ai" target="_blank">ZML.ai</a> </b> — <i>made with <a href="https://zine-ssg.io" target="_blank">Zine</a></i>

        <!-- OPTION 2: ZML only -->
        <!-- &copy; in 2024 by <a href="https://zml.ai" target="_blank">ZML.ai</a> -->
    </footer>
  </body>
</html>
